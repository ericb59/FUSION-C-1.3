/*
 ___________________________________________________________
/               __           _                              \
|              / _|         (_)                             |
|             | |_ _   _ ___ _  ___  _ __                   |
|             |  _| | | / __| |/ _ \| '_ \                  |
|             | | | |_| \__ \ | (_) | | | |                 |
|             |_|  \__,_|___/_|\___/|_| |_| *               |
|                                                           |
|               The MSX C Library for SDCC                  |
|                 E X A M P L E  C O D E                    |
|                                            FUSION-C v1.3  |
\___________________________________________________________/
*/
// Fast VDP example with Sprite Follow Path
//
//  Works on MSX2 and Upper 
//
//  Need external file 
// 		 SPACESHI.SC8

#include "fusion-c/header/msx_fusion.h"
#include "fusion-c/header/vdp_graph2.h"
#include "fusion-c/header/vdp_sprites.h"
#include <stdlib.h>
#include <string.h>


MMMtask t;

static FastVDP MyCommand;
static FCB file;  

static const char path1[]={0x30,0x30,0x30,0x30,0x02,0x30,0x30,0x30,0x30,0x02,0x30,0x30,0x30,0x02,0x30,0x30,0x32,0x30,0x32,0x30,0x32,0x30,0x02,0x30,0x32,0x30,0x02,0x30,0x02,0x30,0x32,0x32,0x30,0x02,0x30,0x02,0x02,0x30,0x02,0x02,0x32,0x02,0x02,0x02,0x20,0x02,0x02,0x02,0x02,0x20,0x02,0x02,0x02,0x22,0x02,0x02,0x22,0x22,0x02,0x22,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x20,0x02,0x20,0x22,0x20,0x02,0x20,0x02,0x20,0x20,0x02,0x20,0x02,0x20,0x20,0x02,0x20,0x20,0x02,0x20,0x20,0x20,0x02,0x20,0x20,0x20,0x20,0x20,0x02,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x03,0x20,0x20,0x20,0x03,0x20,0x20,0x03,0x20,0x20,0x03,0x20,0x20,0x03,0x20,0x20,0x03,0x20,0x03,0x20,0x20,0x03,0x20,0x20,0x03,0x20,0x03,0x20,0x03,0x20,0x03,0x20,0x03,0x20,0x03,0x23,0x03,0x20,0x03,0x03,0x03,0x20,0x03,0x23,0x03,0x03,0x23,0x03,0x03,0x03,0x03,0x20,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x33,0x03,0x03,0x03,0x03,0x30,0x03,0x03,0x33,0x03,0x30,0x03,0x33,0x03,0x30,0x03,0x30,0x03,0x30,0x03,0x30,0x03,0x30,0x33,0x30,0x03,0x30,0x30,0x03,0x30,0x33,0x30,0x03,0x30,0x30,0x30,0x03,0x30,0x30,0x30,0x03,0x30,0x30,0x30,0x30,0x03,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x03,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x03,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x03,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x03,0x30,0x30,0x30,0x30,0x30,0x30,0x03,0x30,0x30,0x30,0x02,0x30,0x30,0x30,0x30,0x02,0x30,0x30,0x30,0x02,0x30,0x32,0x32,0x30,0x02,0x32,0x02,0x02,0x30,0x02,0x30,0x02,0x02,0x30,0x02,0x02,0x02,0x02,0x30,0x02,0x02,0x04,0x02,0x32,0x02,0x02,0x02,0x02,0x02,0x30,0x02,0x02,0x02,0x02,0x02,0x02,0x30,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x22,0x02,0x02,0x02,0x20,0x02,0x02,0x20,0x02,0x02,0x20,0x02,0x20,0x02,0x20,0x20,0x02,0x20,0x20,0x20,0x22,0x20,0x20,0x20,0x20,0x20,0x20,0x23,0x20,0x20,0x20,0x03,0x20,0x20,0x20,0x03,0x20,0x20,0x20,0x03,0x20,0x20,0x03,0x20,0x20,0x23,0x20,0x03,0x20,0x20,0x03,0x20,0x03,0x20,0x03,0x03,0x20,0x03,0x20,0x03,0x03,0x03,0x23,0x03,0x03,0x20,0x03,0x03,0x03,0x23,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03};
typedef struct {
    unsigned char y; 			// important Keep this order
    unsigned char x;
    unsigned char Data;
    // ... you can add other variables from here
} DEF_SPRITE;


typedef struct {
    unsigned char LDbuffer[5120];
} BufferType;

static BufferType MyBuffer;
static DEF_SPRITE Move; 

void FT_SetName( FCB *p_fcb, const char *p_name )  
{
  char i, j;
  memset( p_fcb, 0, sizeof(FCB) );
  for( i = 0; i < 11; i++ ) {
    p_fcb->name[i] = ' ';
  }
  for( i = 0; (i < 8) && (p_name[i] != 0) && (p_name[i] != '.'); i++ ) {
    p_fcb->name[i] =  p_name[i];
  }
  if( p_name[i] == '.' ) {
    i++;
    for( j = 0; (j < 3) && (p_name[i + j] != 0) && (p_name[i + j] != '.'); j++ ) {
      p_fcb->ext[j] =  p_name[i + j] ;
    }
  }
}


void FT_errorHandler(char n, char *name)            
{
  Screen(0);
  SetColors(15,6,6);
  switch (n)
  {
      case 1:
          Print("\n\rFAILED: fcb_open(): ");
          Print(name);
      break;
 
      case 2:
          Print("\n\rFAILED: fcb_close():");
          Print(name);
      break;  
 
      case 3:
          Print("\n\rStop Kidding, run me on MSX2 !");
      break; 

      case 4:
        Print("\n\rFAILED: fcb_write(): ");
        Print(name);
      break;
  }
Exit(0);
}

char FT_LoadImage(char *file_name, unsigned int start_Y, BufferType *Xbuffer)        
    {
        unsigned int width_array[]={256,512,512,256,512,256,256,256};  // width in pixel of each screen mode (syaty at 5)
        char pixels_byte[]={2,4,2,1,2,1,1,1};                          // How many colors are coded in 1 byte. Depending of the screen mode 
        unsigned int nx,ny,rd,BytesPerLine;
        size_t BufferSize;
        
        nx=width_array[_ScreenMode-5];                                  // Determines size of a line
        BytesPerLine=nx / pixels_byte[_ScreenMode-5];                   // Determines the number of bytes for one line                
        BufferSize=sizeof(Xbuffer->LDbuffer);                           // Determines the size of the buffer
        ny=BufferSize / BytesPerLine;                                   // Determines how many lines the buffer can store

        FT_SetName( &file, file_name );
        if(FcbOpen( &file ) != FCB_SUCCESS) 
        {
              FT_errorHandler(1, file_name);
        }

        rd=FcbRead( &file, Xbuffer->LDbuffer, 7 );                       // Skip 7 first bytes of the file  
        while (rd!=0)
        {
             rd=FcbRead( &file, Xbuffer->LDbuffer, ny*BytesPerLine);      //  Read Data From Disc to RAM Buffer)
             HMMC(Xbuffer->LDbuffer, 0,start_Y, nx, ny);                  //  Move the buffer to VRAM. 
             start_Y=start_Y+ny;                                          //  Next Y position where to put data in VRAM
        }

        FcbClose(&file);
return(1);
}


void main(void)
{
		unsigned int max,n;
		
		max = 419;									// Determine how many values inside the Path Table
		n=0;
		Screen(8);
		HMMV(0,0,255,255,0);

		Move.x=101;										
		Move.y=50;

		SpriteOff();
		SetDisplayPage(1);

		FT_LoadImage("SPACESHI.SC8",256,&MyBuffer);
		SetDisplayPage(0);

		MyCommand.sx=123;
		MyCommand.sy=0+256;
		MyCommand.dx=0;
		MyCommand.dy=0;
		MyCommand.nx=65;
		MyCommand.ny=64;
		MyCommand.col=0;
		MyCommand.di=0;
		MyCommand.cmd=opHMMM;
		

		while (Inkey()!=27)
		{
				Move.Data=path1[n];
				SpriteFollow(&Move);			// Decode the path stored in the array
				MyCommand.dx=Move.x;
				MyCommand.dy=Move.y;
				fVDP(&MyCommand);

				n=(n+1) % max;
				
		}

		
		Screen(0);
		Exit(0);



}